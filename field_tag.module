<?php

use Drupal\Core\Entity\EntityInterface;
use Drupal\Core\Entity\FieldableEntityInterface;
use Drupal\Core\Form\FormStateInterface;
use Drupal\field\Entity\FieldConfig;
use Drupal\field_tag\Entity\FieldTag;
use Drupal\field_tag\Plugin\migrate\source\FieldTagContentEntity;
use Drupal\file\Plugin\Field\FieldType\FileFieldItemList;


/**
 * Provide information about field tags and their groups.
 *
 * @return array
 */
function field_tag_tags_info() {
  $data = \Drupal::moduleHandler()->invokeAll('field_tag_tags_info');

  // TODO Add in any tags that are found in the database and describe as
  // "undocumented.".

  return $data;
}


/**
 * Implements hook_form_FORM_ID_form_alter().
 */
function field_tag_form_field_config_edit_form_alter(array &$form, FormStateInterface $form_state) {
  $field = $form_state->getFormObject()->getEntity();
  $settings = $field->getThirdPartySettings('field_tag') + [
      'enabled' => FALSE,
      'title' => t('Tags'),
      'description' => 'Separate multiple tags with a comma.',
      'weight' => 0,
      'required' => FALSE,
    ];
  $form['third_party_settings']['field_tag'] = [
    '#type' => 'details',
    '#title' => t('Field tag'),
    '#description' => t('Enabling tagging for this field adds a textfield to the widget form that allows the admin to tag the value entered in this field with an arbitrary string of text, which can be used by developers to manipulate the field.'),
    '#open' => $settings['enabled'],
  ];
  $form['third_party_settings']['field_tag']['enabled'] = [
    '#type' => 'checkbox',
    '#title' => t('Enable tagging for this field?'),
    '#default_value' => $settings['enabled'],
  ];
  $states = array(
    'visible' => array(
      ':input[name="third_party_settings[field_tag][enabled]"]' => array(
        'checked' => TRUE,
      ),
    ),
  );
  $form['third_party_settings']['field_tag']['title'] = [
    '#type' => 'textfield',
    '#title' => t('Widget field label'),
    '#default_value' => $settings['title'],
    '#required' => TRUE,
    '#states' => $states,
  ];
  $form['third_party_settings']['field_tag']['description'] = [
    '#type' => 'textfield',
    '#title' => t('Widget field description'),
    '#default_value' => $settings['description'],
    '#states' => $states,
  ];
  $form['third_party_settings']['field_tag']['weight'] = array(
    '#type' => 'weight',
    '#title' => t('Weight'),
    '#default_value' => $settings['weight'],
    '#delta' => 50,
    '#states' => $states,
  );
  $form['third_party_settings']['field_tag']['required'] = [
    '#type' => 'checkbox',
    '#title' => t('Make the field required in the widget form.'),
    '#default_value' => $settings['required'],
    '#states' => $states,
  ];
}

/**
 * Implements hook_field_widget_form_alter().
 */
function field_tag_field_widget_form_alter(&$element, FormStateInterface $form_state, $context) {
  if (($field_definition = $context['items']->getFieldDefinition()) instanceof FieldConfig
    && ($settings = $field_definition->getThirdPartySettings('field_tag'))
    && ($settings['enabled'] ?? FALSE)) {

    // On subsequent submissions, such as an AJAX remove of an item in a item
    // list, the field tag entity id will be present in context, we have to use
    // this because the delta is no longer reliable (due to list modification
    // via AJAX in the form).
    $item = $context['items']->get($context['delta']);
    $default_value = \Drupal::service('field_tag')
      ->normalizeItemFieldTag($item);

    // The first time the form is loaded we have to rely on the delta value to
    // locate the correct tag for this item.
    if (is_null($default_value)) {
      $entity = $context['items']->getParent()->getEntity();
      $field_name = $field_definition->getName();

      // This is important to make sure that we do not leave orphaned field tag
      // entities in the database.
      $entity->field_tag_sync[] = $field_name;
      $entity->field_tag_sync = array_unique($entity->field_tag_sync);

      $field_tag = FieldTag::loadByParentField($entity, $field_name, $context['delta']);
      $default_value = (string) $field_tag;
    }

    // We have to attach this also to the item so it passes through correctly in
    // all situations.
    $context['items']->get($context['delta'])->field_tag = $default_value;

    // In some widgets this should not be shown under certain circumstances,
    // e.g., a file field that has no files attached yet, should be seeing the
    // tagging input yet.  Only after it has a file.
    $access = TRUE;
    if ($is_file = $context['items'] instanceof FileFieldItemList) {
      $access = !empty($element['#default_value']['fids']);
    }

    $element['field_tag'] = [
      '#weight' => $settings['weight'],
      '#type' => 'textfield',
      '#required' => $settings['required'],
      '#title' => $settings['title'],
      '#description' => $settings['description'],
      '#default_value' => $default_value,
      '#attributes' => ['class' => ['field-tag']],
      '#access' => $access && \Drupal::currentUser()
          ->hasPermission('access field tag inputs'),
    ];
  }
}

/**
 * Implements hook_entity_insert().
 */
function field_tag_entity_insert(EntityInterface $entity) {
  field_tag_entity_update($entity);
}

/**
 * Implements hook_entity_update().
 *
 * This may synchronize field tags for the entity.  This will only happen under
 * certain conditions:
 *  - if $entity->field_tag_sync contains the field name.
 */
function field_tag_entity_update(EntityInterface $entity) {

  // Ignore processing of certain entity types.
  if (!$entity instanceof FieldableEntityInterface
    || $entity->getEntityTypeId() === 'field_tag') {
    return;
  }

  $field_tag_service = \Drupal::service('field_tag');
  $field_tag_storage = \Drupal::entityTypeManager()->getStorage('field_tag');

  foreach ($entity->getFieldDefinitions() as $field_name => $field_definition) {

    // Only fields that have field tagging enabled are processed.
    if (!$field_definition instanceof FieldConfig
      || !$field_definition->getThirdPartySettings('field_tag')) {
      continue;
    }

    // Determine if we should remove all tags for all items on this field first.
    // This is indicated by assigning a fieldname as an array element on
    // $entity->field_tag_sync.  This happens in
    // field_tag_field_widget_form_alter or could be done by a developer in
    // custom code.
    $should_sync = in_array($field_name, $entity->field_tag_sync ?? []);
    if ($should_sync) {
      $field_tag_instances_to_delete = $field_tag_service
        ->getAllFieldTagsByParent($entity, $field_name);
      if ($field_tag_instances_to_delete) {
        $field_tag_storage->delete($field_tag_instances_to_delete);
      }
    }

    // Now go through and save any data that is present as `field_tag`.
    foreach ($entity->{$field_name} as $delta => $item) {

      // fieldTag instances get detached on save.
      unset($item->fieldTag);

      // We will only perform a field tag entity save if `field_tag` is
      // present on this field item.
      $new_tag_value = $field_tag_service->normalizeItemFieldTag($item);
      if (is_null($new_tag_value)) {
        continue;
      }

      $field_tag = FieldTag::loadByParentField($entity, $field_name, $delta);

      if (!$new_tag_value) {

        // Delete existing field tags when the new value is empty.
        if (!$field_tag->isNew()) {
          $field_tag->delete();
        }
      }

      // Save new ones and those whose new value differs from the old.
      elseif ($field_tag->isNew() || $field_tag->getValue() !== $new_tag_value) {
        $field_tag->get('tag')->value = $new_tag_value;
        $field_tag->save();
      }
    }
  }
}

/**
 * Implements hook_entity_delete().
 *
 * Deletes tags on entities that get deleted.
 */
function field_tag_entity_delete(EntityInterface $entity) {
  if ($entity instanceof FieldableEntityInterface
    && (($field_tags = \Drupal::service('field_tag')
      ->getAllFieldTagsByParent($entity)))) {
    \Drupal::entityTypeManager()
      ->getStorage('field_tag')->delete($field_tags);
  }
}

//function field_tag_form_alter(&$form, FormStateInterface $form_state) {
//  if (empty($form['#entity_type']) || !isset($form['meta'])) {
//    return;
//  }
//  $form['field_tag_visibility'] = [
//    '#type' => 'details',
//    '#title' => t('Tags'),
//    '#attributes' => ['class' => ['node-form-field-tags']],
//    '#group' => 'advanced',
//    [
//      '#markup' => \Drupal\Core\Render\Markup::create(t('<input type="checkbox" class="js-field-tag-visibility"/> Reveal tags')),
//    ],
//  ];
//}


/**
 * Implements hook_migrate_source_info_alter().
 */
function field_tag_migrate_source_info_alter(&$info) {

  // We working with the "content_entity:*" source plugins, we are talking about
  // content in the current datbase, therefore we look to the current database
  // to see what entities have tags and then we modify only those classes in the
  // source plugins, so that when those entity types are loaded, the field tags
  // are automatically attached.
  $entity_types = \Drupal::database()
    ->select('field_tag', 'ft')
    ->fields('ft', ['parent_entity'])
    ->distinct('parent_entity')
    ->execute()
    ->fetchAllAssoc('parent_entity');
  foreach (array_keys($entity_types) as $entity_type) {
    $key = "content_entity:{$entity_type}";
    if (isset($info[$key]) && $info[$key]['requirements_met']) {
      $info[$key]['class'] = FieldTagContentEntity::class;
    }
  }
}
