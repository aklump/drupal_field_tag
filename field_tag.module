<?php

use Drupal\Core\Entity\EntityInterface;
use Drupal\Core\Entity\FieldableEntityInterface;
use Drupal\Core\Form\FormStateInterface;
use Drupal\field\Entity\FieldConfig;
use Drupal\field_tag\Entity\FieldTag;
use Drupal\file\Plugin\Field\FieldType\FileFieldItemList;

/**
 * Implements hook_form_FORM_ID_form_alter().
 */
function field_tag_form_field_config_edit_form_alter(array &$form, FormStateInterface $form_state) {
  $field = $form_state->getFormObject()->getEntity();
  $settings = $field->getThirdPartySettings('field_tag') + [
      'enabled' => FALSE,
      'title' => t('Tags'),
      'description' => 'Separate multiple tags with a comma.',
      'weight' => 0,
      'required' => FALSE,
    ];
  $form['third_party_settings']['field_tag'] = [
    '#type' => 'details',
    '#title' => t('Field tag'),
    '#description' => t('Enabling tagging for this field adds a textfield to the widget form that allows the admin to tag the value entered in this field with an arbitrary string of text, which can be used by developers to manipulate the field.'),
    '#open' => $settings['enabled'],
  ];
  $form['third_party_settings']['field_tag']['enabled'] = [
    '#type' => 'checkbox',
    '#title' => t('Enable tagging for this field?'),
    '#default_value' => $settings['enabled'],
  ];
  $states = array(
    'visible' => array(
      ':input[name="third_party_settings[field_tag][enabled]"]' => array(
        'checked' => TRUE,
      ),
    ),
  );
  $form['third_party_settings']['field_tag']['title'] = [
    '#type' => 'textfield',
    '#title' => t('Widget field label'),
    '#default_value' => $settings['title'],
    '#required' => TRUE,
    '#states' => $states,
  ];
  $form['third_party_settings']['field_tag']['description'] = [
    '#type' => 'textfield',
    '#title' => t('Widget field description'),
    '#default_value' => $settings['description'],
    '#states' => $states,
  ];
  $form['third_party_settings']['field_tag']['weight'] = array(
    '#type' => 'weight',
    '#title' => t('Weight'),
    '#default_value' => $settings['weight'],
    '#delta' => 50,
    '#states' => $states,
  );
  $form['third_party_settings']['field_tag']['required'] = [
    '#type' => 'checkbox',
    '#title' => t('Make the field required in the widget form.'),
    '#default_value' => $settings['required'],
    '#states' => $states,
  ];
}

/**
 * Implements hook_field_widget_form_alter().
 */
function field_tag_field_widget_form_alter(&$element, FormStateInterface $form_state, $context) {
  if (($field_definition = $context['items']->getFieldDefinition()) instanceof FieldConfig
    && ($settings = $field_definition->getThirdPartySettings('field_tag'))
    && ($settings['enabled'] ?? FALSE)) {

    $item = $context['items']->get($context['delta']);
    $data = \Drupal::service('field_tag')
      ->normalizeItemFieldTag($item);

    // The first time the form is loaded we have to rely on the delta value to
    // locate the correct tag for this item.
    if (is_null($data)) {
      $entity = $context['items']->getParent()->getEntity();
      $field_name = $field_definition->getName();

      // This is important to make sure that we do not leave orphaned field tag
      // entities in the database.
      $entity->field_tag_sync[] = $field_name;
      $entity->field_tag_sync = array_unique($entity->field_tag_sync);

      $field_tag = FieldTag::loadByParentField($entity, $field_name, $context['delta']);
      $default_value = (string) $field_tag;
      $field_tag_id = $field_tag->id() ?? NULL;
    }

    // On subsequent submissions, such as an AJAX remove of an item in a item
    // list, the field tag entity id will be present in context, we have to use
    // this because the delta is no longer reliable (due to list modification
    // via AJAX in the form).
    else {
      $default_value = $data['tag'] ?? '';
      $field_tag_id = $data['target_id'] ?? NULL;
    }

    // We have to attach this also to the item so it passes through correctly in
    // all situations.
    $context['items']->get($context['delta'])->field_tag = [
      'tag' => $default_value,
      'target_id' => $field_tag_id,
    ];

    // In some widgets this should not be shown under certain circumstances,
    // e.g., a file field that has no files attached yet, should be seeing the
    // tagging input yet.  Only after it has a file.
    $access = TRUE;
    if ($is_file = $context['items'] instanceof FileFieldItemList) {
      $access = !empty($element['#default_value']['fids']);
    }

    // Store the target_id of the field tag for proper reference if the delta
    // become irrelevant (see above).
    $element['field_tag']['target_id'] = [
      '#type' => 'value',
      '#value' => $field_tag_id,
    ];
    $element['field_tag']['tag'] = [
      '#weight' => $settings['weight'],
      '#type' => 'textfield',
      '#required' => $settings['required'],
      '#title' => $settings['title'],
      '#description' => $settings['description'],
      '#default_value' => $default_value,
      '#attributes' => ['class' => ['field-tag']],
      '#access' => $access && \Drupal::currentUser()
          ->hasPermission('access field tag inputs'),
    ];
  }
}

/**
 * Implements hook_entity_insert().
 */
function field_tag_entity_insert(EntityInterface $entity) {
  field_tag_entity_update($entity);
}

/**
 * Implements hook_entity_update().
 *
 * This may synchronize field tags for the entity.  This will only happen under
 * certain conditions:
 *  - if $entity->field_tag_sync contains the field name.
 */
function field_tag_entity_update(EntityInterface $entity) {
  if (!$entity instanceof FieldableEntityInterface) {
    return;
  }

  if ($entity->getEntityTypeId() === 'field_tag') {
    return;
  }

  foreach ($entity->getFieldDefinitions() as $field_name => $field_definition) {

    if ($field_definition instanceof FieldConfig
      && ($field_definition->getThirdPartySettings('field_tag'))) {

      $field_tag_service = \Drupal::service('field_tag');

      // Determine if we should remove all tags for all items on this field first.
      $should_sync = in_array($field_name, $entity->field_tag_sync ?? []);
      if ($should_sync) {
        $field_tag_instances_to_delete = $field_tag_service
          ->getAllFieldTagsByParent($entity, $field_name);
        foreach ($field_tag_instances_to_delete as $field_tag) {
          $field_tag->delete();
        }
      }

      // Now go through and save any data that is present as `field_tag`.
      foreach ($entity->{$field_name} as $delta => $item) {

        // We will only perform a field tag entity save if `field_tag` is
        // present on this field item.
        $data = $field_tag_service->normalizeItemFieldTag($item);
        if (!is_null($data)) {

          $field_tag = FieldTag::loadByParentField($entity, $field_name, $delta);
          if ($field_tag->isNew() || $field_tag->getValue() !== $data['tag']) {
            $field_tag->get('tag')->value = $data['tag'];
            $field_tag->save();

            // fieldTag instances get detached if the field tag is saved.
            unset($item->fieldTag);
          }
        }
      }
    }
  }
}

/**
 * Implements hook_entity_delete().
 *
 * Deletes tags on entities that get deleted.
 */
function field_tag_entity_delete(EntityInterface $entity) {
  if ($entity instanceof FieldableEntityInterface
    && (($field_tags = \Drupal::service('field_tag')
      ->getAllFieldTagsByParent($entity)))) {
    \Drupal::entityTypeManager()
      ->getStorage('field_tag')->delete($field_tags);
  }

}
